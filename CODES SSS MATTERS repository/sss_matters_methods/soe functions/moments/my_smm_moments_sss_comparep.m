function y=my_smm_moments_sss_comparep(xopt,replications,innovations,model,params,my_dss_params,M,eps_ind,approx0,approx1,Ti,pruning)
% Inputs:
%   xopt                            vector of parameters in current optimization step 
%   replications                    number of simulation replications
%   innovations                     matrix of shocks for simulation
%   model                           mat file generated by Levintal's code
%   params                          vector of model parameters
%   my_dss_params                   subset of model parameters
%   M                               matrices of theoretical cross moments of innovations
%   eps_ind                         index of perturbation variable
%   approx0                         order of approximation for SSS
%   approx1                         order of approximation for solution
%   Ti                              burn-in number of periods
%   pruning                         pruning dummy
% Outputs:
%   y                               A vector of simulated_moments

load('model','symparams');

phi_d = exp(xopt(1));params(symparams=='phi_d') = phi_d;
phipar=xopt(2)^2; params(symparams=='phipar') = phipar;
sigma_x = (xopt(3)); params(symparams=='sigma_x') = sigma_x;
D1 = (xopt(4)); params(symparams=='D_bar') = D1;
%uncomment this to get real-time report during estimation
current_vals = [phi_d phipar sigma_x D1]

eta_r = params(symparams=='eta_r');
eta_tb = params(symparams=='eta_tb');
eta=[0 0 0 0 0;0 0 0 0 0;0 0 0 0 0;eta_r 0 0 0 0;0 eta_tb 0 0 0;0 0 0 0 0;0 0 0 0 0;0 0 1 0 0;0 0 0 1 0;0 0 0 0 exp(sigma_x);0 0 0 0 0];

Kstar0 = (my_Kstar(my_dss_params)); %DSS capital of original FGRU model (useful as initial guess)
%Compute SSS in calibration mode
sss_sol = compute_betta_fgru_3p(D1,model,params,my_dss_params,M,eta,eps_ind,approx0,[-0.01 0.95*log(Kstar0) 0]);
%Compute aux. DSS and change parameters as needed
[nxss,nyss,psi_k,C_bar] = my_dss_aux([D1 sss_sol(2:3)],my_dss_params);
params(symparams=='C_bar') = C_bar;
params(symparams=='psibetta') = sss_sol(1);
params(symparams=='psi_k') = psi_k;
params(symparams=='psi_i') = sss_sol(3);

%Compute up to k-order derivatives
%use Levintal's function solve_dsge.m
algo='vectorize'; % Simple vectorization.
%algo='dlyap'; % Hessenberg-Schur algorithm.
%algo='gensylv'; % Kamenik algorithm
derivs=solve_dsge(model,params,M,eta,nxss,nyss,approx1,algo);

%--------------------------------------------------------------------------
%SSS (for net exports over GDP)
%--------------------------------------------------------------------------
x0=nxss; % start at the steady state
derivs.hx(eps_ind,eps_ind) = 1;
x0(eps_ind) = 1; %impose the model of interest (epsilon=1)

T0 = 1;
T = 1;
shocks0 = zeros(5,(T0 + (T-1)));

[myt,mxt]=simul(x0,shocks0,nyss,nxss,eta,derivs,approx1,0,model);

myt = myt(:,T0+1:end);
mxt = mxt(:,T0+1:end);

y_sss = exp(myt(5));
c_sss = exp(myt(1));
i_sss = exp(myt(7));

nx_y_sss = 100*(y_sss - c_sss - i_sss)/y_sss;
%keyboard;

%--------------------------------------------------------------------------
%stochastic simulations
%--------------------------------------------------------------------------

moments = zeros(14,1);
for t=1:replications
    
    shocks = innovations(:,:,t);
    if pruning==1
        [myt_sim,~]=simul_mod_pruning3(mxt,shocks,nyss,nxss,eta,derivs);
    else
        [myt_sim,~]=simul(mxt,shocks,nyss,nxss,eta,derivs,approx1,0,model);
    end
    
    myt_sim = myt_sim(:,Ti+1:end);
    myt_sim_exp = exp(myt_sim);
    moments(: ,t) = quarterly_moments_5p_full(myt_sim_exp);
 
end


std_y = (moments(1,:));
std_c_y = (moments(2,:));
std_i_y = (moments(3,:));
std_nx_y = moments(4,:);
corr_nxy_y = moments(7,:);

%average moments
m_std_y = mean(std_y)*100;
m_std_c_y = mean(std_c_y);
m_std_i_y = mean(std_i_y);
m_std_nx_y = mean(std_nx_y);

m_corr_nxy_y = mean(corr_nxy_y);

%y = simulated_moments;
y = [m_std_y;m_std_c_y;m_std_i_y;nx_y_sss;m_std_nx_y*100;m_corr_nxy_y];